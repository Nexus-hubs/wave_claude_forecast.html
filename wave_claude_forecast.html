<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Wave Claude Forecast</title>

<!--
Open Meteo API Endpoints Used:

Geocoding (location search):
https://geocoding-api.open-meteo.com/v1/search?name={query}&count=5&language=en&format=json

Marine Forecast (wave data):
https://marine-api.open-meteo.com/v1/marine?latitude={lat}&longitude={lon}&hourly=wave_height,wave_direction,wave_period,wind_wave_height,swell_wave_height,swell_wave_direction,swell_wave_period&daily=wave_height_max,wave_direction_dominant,wave_period_max&timezone=auto

Weather Forecast:
https://api.open-meteo.com/v1/forecast?latitude={lat}&longitude={lon}&hourly=temperature_2m,precipitation,wind_speed_10m,wind_direction_10m&daily=temperature_2m_max,temperature_2m_min,precipitation_sum&timezone=auto
-->

<style>
:root {
  --bg: #000000;
  --fg: #ffffff;
  --muted: #888888;
  --card: #0a0a0a;
  --card-border: #1a1a1a;
  --accent: #00d4ff;
  --accent-dim: #006680;
  --good: #00ff88;
  --warn: #ffaa00;
  --bad: #ff4444;
  --radius: 12px;
  --transition: 0.2s ease;
}

* { box-sizing: border-box; margin: 0; padding: 0; }

html { scroll-behavior: smooth; }

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
  background: var(--bg);
  color: var(--fg);
  min-height: 100vh;
  line-height: 1.5;
}

/* Header */
header {
  position: sticky;
  top: 0;
  background: rgba(0,0,0,0.9);
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  border-bottom: 1px solid var(--card-border);
  padding: 12px 16px;
  z-index: 100;
}

.header-top {
  display: flex;
  align-items: center;
  gap: 12px;
}

.brand {
  font-size: 18px;
  font-weight: 700;
  letter-spacing: -0.5px;
  white-space: nowrap;
}

.brand span { color: var(--accent); }

.search-container {
  flex: 1;
  position: relative;
  max-width: 400px;
}

#search {
  width: 100%;
  background: #111;
  color: var(--fg);
  border: 1px solid var(--card-border);
  border-radius: var(--radius);
  padding: 10px 14px;
  font-size: 14px;
  outline: none;
  transition: border-color var(--transition);
}

#search:focus { border-color: var(--accent); }

#search::placeholder { color: var(--muted); }

.autocomplete {
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  background: #111;
  border: 1px solid var(--card-border);
  border-radius: var(--radius);
  margin-top: 4px;
  max-height: 240px;
  overflow-y: auto;
  display: none;
  z-index: 50;
}

.autocomplete.show { display: block; }

.autocomplete-item {
  padding: 10px 14px;
  cursor: pointer;
  border-bottom: 1px solid var(--card-border);
  transition: background var(--transition);
}

.autocomplete-item:last-child { border-bottom: none; }
.autocomplete-item:hover { background: #1a1a1a; }

.autocomplete-item .name { font-weight: 500; }
.autocomplete-item .country { color: var(--muted); font-size: 12px; }

.header-controls {
  display: flex;
  gap: 8px;
  align-items: center;
}

.icon-btn {
  background: transparent;
  border: 1px solid var(--card-border);
  color: var(--fg);
  width: 36px;
  height: 36px;
  border-radius: 8px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all var(--transition);
}

.icon-btn:hover { border-color: var(--accent); color: var(--accent); }
.icon-btn.active { background: var(--accent); border-color: var(--accent); color: #000; }

/* Quick Regions */
.quick-regions {
  display: flex;
  gap: 8px;
  margin-top: 12px;
  flex-wrap: wrap;
}

.region-btn {
  background: #111;
  border: 1px solid var(--card-border);
  color: var(--fg);
  padding: 6px 12px;
  border-radius: 20px;
  font-size: 12px;
  cursor: pointer;
  transition: all var(--transition);
  white-space: nowrap;
}

.region-btn:hover { border-color: var(--accent); color: var(--accent); }

/* Favorites */
.favorites-row {
  display: flex;
  gap: 8px;
  margin-top: 8px;
  flex-wrap: wrap;
}

.fav-btn {
  background: var(--accent-dim);
  border: none;
  color: var(--fg);
  padding: 4px 10px;
  border-radius: 16px;
  font-size: 11px;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 4px;
}

.fav-btn .remove {
  opacity: 0.6;
  margin-left: 2px;
}

.fav-btn:hover .remove { opacity: 1; }

/* Main Content */
main {
  padding: 16px;
  max-width: 1400px;
  margin: 0 auto;
}

/* Status Bar */
.status-bar {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 16px;
  flex-wrap: wrap;
  gap: 8px;
}

.location-display {
  display: flex;
  align-items: center;
  gap: 8px;
}

.location-name {
  font-size: 20px;
  font-weight: 600;
}

.location-coords {
  color: var(--muted);
  font-size: 12px;
}

.fav-star {
  background: transparent;
  border: none;
  color: var(--muted);
  font-size: 20px;
  cursor: pointer;
  transition: color var(--transition);
}

.fav-star:hover, .fav-star.active { color: gold; }

.cache-badge {
  background: var(--warn);
  color: #000;
  padding: 4px 8px;
  border-radius: 4px;
  font-size: 11px;
  font-weight: 600;
  display: none;
}

.cache-badge.show { display: inline-block; }

/* Cards Grid */
.cards-grid {
  display: grid;
  grid-template-columns: 1fr;
  gap: 16px;
}

@media (min-width: 768px) {
  .cards-grid { grid-template-columns: repeat(2, 1fr); }
}

@media (min-width: 1200px) {
  .cards-grid { grid-template-columns: repeat(3, 1fr); }
}

.card {
  background: var(--card);
  border: 1px solid var(--card-border);
  border-radius: var(--radius);
  padding: 20px;
}

.card-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 16px;
}

.card h2 {
  font-size: 12px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--muted);
}

.card-full { grid-column: 1 / -1; }

/* Current Conditions */
.current-main {
  display: flex;
  align-items: center;
  gap: 20px;
  margin-bottom: 20px;
}

.wave-height-big {
  font-size: 48px;
  font-weight: 700;
  line-height: 1;
}

.wave-height-big span {
  font-size: 20px;
  font-weight: 400;
  color: var(--muted);
}

.wave-details { flex: 1; }

.wave-detail-row {
  display: flex;
  justify-content: space-between;
  padding: 4px 0;
  border-bottom: 1px solid var(--card-border);
}

.wave-detail-row:last-child { border-bottom: none; }

.detail-label { color: var(--muted); font-size: 13px; }
.detail-value { font-weight: 500; font-size: 14px; }

.conditions-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 12px;
}

@media (min-width: 480px) {
  .conditions-grid { grid-template-columns: repeat(4, 1fr); }
}

.condition-item {
  background: #111;
  padding: 12px;
  border-radius: 8px;
  text-align: center;
}

.condition-icon { font-size: 24px; margin-bottom: 4px; }
.condition-value { font-size: 18px; font-weight: 600; }
.condition-label { font-size: 11px; color: var(--muted); }

/* Direction Arrow */
.direction-arrow {
  display: inline-block;
  transition: transform var(--transition);
}

/* Surf Quality */
.quality-rating {
  display: flex;
  align-items: center;
  gap: 16px;
  margin-bottom: 16px;
}

.quality-score {
  font-size: 36px;
  font-weight: 700;
}

.quality-stars { font-size: 20px; letter-spacing: 2px; }
.quality-label { font-size: 14px; color: var(--muted); }

.quality-explanation {
  background: #111;
  padding: 12px;
  border-radius: 8px;
  font-size: 13px;
  color: var(--muted);
  line-height: 1.6;
}

/* Timeline */
.timeline-scroll {
  overflow-x: auto;
  margin: 0 -20px;
  padding: 0 20px;
  scrollbar-width: thin;
  scrollbar-color: var(--accent-dim) transparent;
}

.timeline-scroll::-webkit-scrollbar { height: 6px; }
.timeline-scroll::-webkit-scrollbar-track { background: transparent; }
.timeline-scroll::-webkit-scrollbar-thumb { background: var(--accent-dim); border-radius: 3px; }

.timeline {
  display: flex;
  gap: 8px;
  padding-bottom: 8px;
}

.timeline-item {
  flex-shrink: 0;
  width: 70px;
  background: #111;
  padding: 12px 8px;
  border-radius: 8px;
  text-align: center;
  transition: background var(--transition);
}

.timeline-item:hover { background: #1a1a1a; }
.timeline-item.now { border: 1px solid var(--accent); }

.timeline-time { font-size: 11px; color: var(--muted); margin-bottom: 6px; }
.timeline-wave { font-size: 16px; font-weight: 600; margin-bottom: 4px; }
.timeline-wind { font-size: 11px; color: var(--muted); }
.timeline-temp { font-size: 11px; color: var(--accent); }

/* 7-Day Forecast */
.daily-grid {
  display: grid;
  grid-template-columns: repeat(7, 1fr);
  gap: 8px;
}

@media (max-width: 768px) {
  .daily-grid {
    display: flex;
    overflow-x: auto;
    margin: 0 -20px;
    padding: 0 20px;
    gap: 8px;
  }
  .daily-item { flex-shrink: 0; width: 100px; }
}

.daily-item {
  background: #111;
  padding: 16px 12px;
  border-radius: 8px;
  text-align: center;
}

.daily-day { font-size: 12px; font-weight: 600; margin-bottom: 8px; }
.daily-wave { font-size: 20px; font-weight: 700; margin-bottom: 4px; }
.daily-period { font-size: 11px; color: var(--muted); }
.daily-temp { font-size: 12px; color: var(--accent); margin-top: 8px; }

/* Settings Modal */
.modal-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.8);
  z-index: 200;
  display: none;
  align-items: center;
  justify-content: center;
  padding: 20px;
}

.modal-overlay.show { display: flex; }

.modal {
  background: var(--card);
  border: 1px solid var(--card-border);
  border-radius: var(--radius);
  padding: 24px;
  max-width: 400px;
  width: 100%;
}

.modal h3 {
  font-size: 18px;
  margin-bottom: 20px;
}

.setting-group {
  margin-bottom: 20px;
}

.setting-label {
  font-size: 12px;
  color: var(--muted);
  text-transform: uppercase;
  margin-bottom: 8px;
}

.setting-options {
  display: flex;
  gap: 8px;
}

.setting-btn {
  flex: 1;
  background: #111;
  border: 1px solid var(--card-border);
  color: var(--fg);
  padding: 10px;
  border-radius: 8px;
  cursor: pointer;
  transition: all var(--transition);
}

.setting-btn:hover { border-color: var(--accent); }
.setting-btn.active { background: var(--accent); border-color: var(--accent); color: #000; }

.audio-control {
  display: flex;
  align-items: center;
  gap: 12px;
}

.volume-slider {
  flex: 1;
  -webkit-appearance: none;
  appearance: none;
  height: 4px;
  background: #333;
  border-radius: 2px;
  outline: none;
}

.volume-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 16px;
  height: 16px;
  background: var(--accent);
  border-radius: 50%;
  cursor: pointer;
}

.modal-close {
  width: 100%;
  background: #222;
  border: none;
  color: var(--fg);
  padding: 12px;
  border-radius: 8px;
  cursor: pointer;
  margin-top: 10px;
  transition: background var(--transition);
}

.modal-close:hover { background: #333; }

/* States */
.empty-state, .loading-state, .error-state {
  text-align: center;
  padding: 60px 20px;
  color: var(--muted);
}

.empty-state .icon, .loading-state .icon, .error-state .icon {
  font-size: 48px;
  margin-bottom: 16px;
}

.loading-state .icon { animation: pulse 1.5s infinite; }

@keyframes pulse {
  0%, 100% { opacity: 0.4; }
  50% { opacity: 1; }
}

.error-state { color: var(--bad); }

.retry-btn {
  background: var(--accent);
  border: none;
  color: #000;
  padding: 10px 20px;
  border-radius: 8px;
  cursor: pointer;
  margin-top: 16px;
  font-weight: 500;
}

/* Footer */
footer {
  text-align: center;
  padding: 32px 16px;
  color: var(--muted);
  font-size: 12px;
  border-top: 1px solid var(--card-border);
}

footer a { color: var(--accent); text-decoration: none; }
footer a:hover { text-decoration: underline; }

/* Accessibility */
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0,0,0,0);
  border: 0;
}

/* Reduced motion */
@media (prefers-reduced-motion: reduce) {
  *, *::before, *::after {
    animation-duration: 0.01ms !important;
    transition-duration: 0.01ms !important;
  }
}
</style>
</head>

<body>
<header>
  <div class="header-top">
    <div class="brand">Wave <span>Claude</span></div>
    <div class="search-container">
      <input type="search" id="search" placeholder="Search location..." aria-label="Search for a surf location" autocomplete="off">
      <div class="autocomplete" id="autocomplete" role="listbox" aria-label="Location suggestions"></div>
    </div>
    <div class="header-controls">
      <button class="icon-btn" id="audio-toggle" aria-label="Toggle audio" title="Toggle audio">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 5L6 9H2v6h4l5 4V5z"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/></svg>
      </button>
      <button class="icon-btn" id="settings-btn" aria-label="Settings" title="Settings">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><path d="M12 1v4M12 19v4M4.22 4.22l2.83 2.83M16.95 16.95l2.83 2.83M1 12h4M19 12h4M4.22 19.78l2.83-2.83M16.95 7.05l2.83-2.83"/></svg>
      </button>
    </div>
  </div>
  <div class="quick-regions" id="quick-regions" aria-label="Quick access surf spots"></div>
  <div class="favorites-row" id="favorites-row" aria-label="Favorite locations"></div>
</header>

<main id="main-content">
  <div class="empty-state" id="empty-state">
    <div class="icon">üåä</div>
    <h2>Wave Claude Forecast</h2>
    <p>Search for a location or select a surf spot above</p>
  </div>

  <div id="forecast-content" style="display: none;">
    <div class="status-bar">
      <div class="location-display">
        <span class="location-name" id="location-name"></span>
        <button class="fav-star" id="fav-star" aria-label="Add to favorites">‚òÜ</button>
        <span class="cache-badge" id="cache-badge">CACHED</span>
      </div>
      <span class="location-coords" id="location-coords"></span>
    </div>

    <div class="cards-grid">
      <!-- Current Conditions -->
      <div class="card">
        <div class="card-header">
          <h2>Current Conditions</h2>
        </div>
        <div class="current-main">
          <div class="wave-height-big" id="current-wave">--<span>m</span></div>
          <div class="wave-details">
            <div class="wave-detail-row">
              <span class="detail-label">Period</span>
              <span class="detail-value" id="current-period">--s</span>
            </div>
            <div class="wave-detail-row">
              <span class="detail-label">Direction</span>
              <span class="detail-value" id="current-direction">-- <span class="direction-arrow">‚Üë</span></span>
            </div>
            <div class="wave-detail-row">
              <span class="detail-label">Swell</span>
              <span class="detail-value" id="current-swell">--m</span>
            </div>
          </div>
        </div>
        <div class="conditions-grid">
          <div class="condition-item">
            <div class="condition-icon">üí®</div>
            <div class="condition-value" id="current-wind">--</div>
            <div class="condition-label">Wind</div>
          </div>
          <div class="condition-item">
            <div class="condition-icon">üß≠</div>
            <div class="condition-value" id="current-wind-dir">--</div>
            <div class="condition-label">Wind Dir</div>
          </div>
          <div class="condition-item">
            <div class="condition-icon">üå°Ô∏è</div>
            <div class="condition-value" id="current-temp">--</div>
            <div class="condition-label">Temp</div>
          </div>
          <div class="condition-item">
            <div class="condition-icon">üåßÔ∏è</div>
            <div class="condition-value" id="current-precip">--</div>
            <div class="condition-label">Precip</div>
          </div>
        </div>
      </div>

      <!-- Surf Quality -->
      <div class="card">
        <div class="card-header">
          <h2>Surf Quality</h2>
        </div>
        <div class="quality-rating">
          <div class="quality-score" id="quality-score">--</div>
          <div>
            <div class="quality-stars" id="quality-stars">‚òÜ‚òÜ‚òÜ‚òÜ‚òÜ</div>
            <div class="quality-label" id="quality-label">Select a location</div>
          </div>
        </div>
        <div class="quality-explanation" id="quality-explanation">
          Search for a surf spot to see conditions analysis.
        </div>
      </div>

      <!-- 48-Hour Timeline -->
      <div class="card card-full">
        <div class="card-header">
          <h2>48-Hour Forecast</h2>
        </div>
        <div class="timeline-scroll">
          <div class="timeline" id="timeline"></div>
        </div>
      </div>

      <!-- 7-Day Outlook -->
      <div class="card card-full">
        <div class="card-header">
          <h2>7-Day Outlook</h2>
        </div>
        <div class="daily-grid" id="daily-forecast"></div>
      </div>
    </div>
  </div>

  <div class="loading-state" id="loading-state" style="display: none;">
    <div class="icon">üåä</div>
    <p>Loading forecast...</p>
  </div>

  <div class="error-state" id="error-state" style="display: none;">
    <div class="icon">‚ö†Ô∏è</div>
    <p id="error-message">Failed to load forecast</p>
    <button class="retry-btn" id="retry-btn">Retry</button>
  </div>
</main>

<footer>
  Powered by <a href="https://open-meteo.com/" target="_blank" rel="noopener">Open-Meteo</a> free API
</footer>

<!-- Settings Modal -->
<div class="modal-overlay" id="settings-modal">
  <div class="modal" role="dialog" aria-labelledby="settings-title">
    <h3 id="settings-title">Settings</h3>

    <div class="setting-group">
      <div class="setting-label">Wave Height</div>
      <div class="setting-options">
        <button class="setting-btn active" data-setting="wave" data-value="m">Meters</button>
        <button class="setting-btn" data-setting="wave" data-value="ft">Feet</button>
      </div>
    </div>

    <div class="setting-group">
      <div class="setting-label">Wind Speed</div>
      <div class="setting-options">
        <button class="setting-btn active" data-setting="wind" data-value="ms">m/s</button>
        <button class="setting-btn" data-setting="wind" data-value="kmh">km/h</button>
        <button class="setting-btn" data-setting="wind" data-value="mph">mph</button>
      </div>
    </div>

    <div class="setting-group">
      <div class="setting-label">Temperature</div>
      <div class="setting-options">
        <button class="setting-btn active" data-setting="temp" data-value="c">Celsius</button>
        <button class="setting-btn" data-setting="temp" data-value="f">Fahrenheit</button>
      </div>
    </div>

    <div class="setting-group">
      <div class="setting-label">Time Format</div>
      <div class="setting-options">
        <button class="setting-btn active" data-setting="time" data-value="24">24-hour</button>
        <button class="setting-btn" data-setting="time" data-value="12">12-hour</button>
      </div>
    </div>

    <div class="setting-group">
      <div class="setting-label">Audio</div>
      <div class="audio-control">
        <button class="setting-btn" id="audio-enable" style="flex: 0 0 auto; padding: 10px 16px;">Off</button>
        <input type="range" class="volume-slider" id="volume-slider" min="0" max="100" value="30" aria-label="Volume">
      </div>
    </div>

    <button class="modal-close" id="settings-close">Close</button>
  </div>
</div>

<script>
(function() {
  'use strict';

  // ============ STATE ============
  const state = {
    location: null,
    forecast: null,
    isCached: false,
    isOnline: navigator.onLine,
    audioEnabled: false,
    audioContext: null,
    masterGain: null,
    ambientOsc: null
  };

  // ============ SETTINGS ============
  const defaultSettings = {
    wave: 'm',
    wind: 'ms',
    temp: 'c',
    time: '24',
    volume: 30,
    favorites: []
  };

  let settings = { ...defaultSettings };

  function loadSettings() {
    try {
      const saved = localStorage.getItem('waveclaude_settings');
      if (saved) {
        settings = { ...defaultSettings, ...JSON.parse(saved) };
      }
    } catch (e) { console.error('Failed to load settings', e); }
  }

  function saveSettings() {
    try {
      localStorage.setItem('waveclaude_settings', JSON.stringify(settings));
    } catch (e) { console.error('Failed to save settings', e); }
  }

  // ============ QUICK REGIONS ============
  const quickRegions = [
    { name: 'Pipeline', country: 'Hawaii', lat: 21.6649, lon: -158.0535 },
    { name: 'Nazare', country: 'Portugal', lat: 39.6013, lon: -9.0701 },
    { name: "Teahupoo", country: 'Tahiti', lat: -17.8378, lon: -149.2706 },
    { name: 'Gold Coast', country: 'Australia', lat: -28.0167, lon: 153.4000 },
    { name: 'Bali', country: 'Indonesia', lat: -8.7225, lon: 115.1690 },
    { name: 'J-Bay', country: 'South Africa', lat: -34.0402, lon: 24.9287 }
  ];

  // ============ DOM REFS ============
  const dom = {
    search: document.getElementById('search'),
    autocomplete: document.getElementById('autocomplete'),
    quickRegions: document.getElementById('quick-regions'),
    favoritesRow: document.getElementById('favorites-row'),
    emptyState: document.getElementById('empty-state'),
    forecastContent: document.getElementById('forecast-content'),
    loadingState: document.getElementById('loading-state'),
    errorState: document.getElementById('error-state'),
    errorMessage: document.getElementById('error-message'),
    retryBtn: document.getElementById('retry-btn'),
    locationName: document.getElementById('location-name'),
    locationCoords: document.getElementById('location-coords'),
    favStar: document.getElementById('fav-star'),
    cacheBadge: document.getElementById('cache-badge'),
    currentWave: document.getElementById('current-wave'),
    currentPeriod: document.getElementById('current-period'),
    currentDirection: document.getElementById('current-direction'),
    currentSwell: document.getElementById('current-swell'),
    currentWind: document.getElementById('current-wind'),
    currentWindDir: document.getElementById('current-wind-dir'),
    currentTemp: document.getElementById('current-temp'),
    currentPrecip: document.getElementById('current-precip'),
    qualityScore: document.getElementById('quality-score'),
    qualityStars: document.getElementById('quality-stars'),
    qualityLabel: document.getElementById('quality-label'),
    qualityExplanation: document.getElementById('quality-explanation'),
    timeline: document.getElementById('timeline'),
    dailyForecast: document.getElementById('daily-forecast'),
    audioToggle: document.getElementById('audio-toggle'),
    settingsBtn: document.getElementById('settings-btn'),
    settingsModal: document.getElementById('settings-modal'),
    settingsClose: document.getElementById('settings-close'),
    audioEnable: document.getElementById('audio-enable'),
    volumeSlider: document.getElementById('volume-slider')
  };

  // ============ UTILITIES ============
  function debounce(fn, delay) {
    let timer;
    return function(...args) {
      clearTimeout(timer);
      timer = setTimeout(() => fn.apply(this, args), delay);
    };
  }

  function formatTime(dateStr, is24h = true) {
    const date = new Date(dateStr);
    if (is24h) {
      return date.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' });
    }
    return date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
  }

  function formatDay(dateStr) {
    const date = new Date(dateStr);
    return date.toLocaleDateString('en-US', { weekday: 'short' });
  }

  function convertWave(meters) {
    if (meters == null) return '--';
    if (settings.wave === 'ft') return (meters * 3.28084).toFixed(1);
    return meters.toFixed(1);
  }

  function convertWind(ms) {
    if (ms == null) return '--';
    if (settings.wind === 'kmh') return (ms * 3.6).toFixed(0);
    if (settings.wind === 'mph') return (ms * 2.237).toFixed(0);
    return ms.toFixed(1);
  }

  function convertTemp(celsius) {
    if (celsius == null) return '--';
    if (settings.temp === 'f') return ((celsius * 9/5) + 32).toFixed(0);
    return celsius.toFixed(0);
  }

  function getWaveUnit() { return settings.wave === 'ft' ? 'ft' : 'm'; }
  function getWindUnit() {
    if (settings.wind === 'kmh') return 'km/h';
    if (settings.wind === 'mph') return 'mph';
    return 'm/s';
  }
  function getTempUnit() { return settings.temp === 'f' ? 'F' : 'C'; }

  function directionToArrow(degrees) {
    if (degrees == null) return '‚Üë';
    const arrows = ['‚Üì', '‚Üô', '‚Üê', '‚Üñ', '‚Üë', '‚Üó', '‚Üí', '‚Üò'];
    const index = Math.round(degrees / 45) % 8;
    return arrows[index];
  }

  function directionToText(degrees) {
    if (degrees == null) return '--';
    const dirs = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
    return dirs[Math.round(degrees / 45) % 8];
  }

  // ============ SURF QUALITY HEURISTIC ============
  function calculateSurfQuality(waveHeight, wavePeriod, windSpeed, windDir, waveDir) {
    if (waveHeight == null || wavePeriod == null) {
      return { score: 0, stars: 0, label: 'Unknown', explanation: 'Insufficient data to analyze conditions.' };
    }

    let score = 0;
    const factors = [];

    // Wave height score (0-25)
    if (waveHeight >= 1 && waveHeight <= 3) {
      score += 25;
      factors.push('Ideal wave height for most surfers');
    } else if (waveHeight >= 0.5 && waveHeight < 1) {
      score += 15;
      factors.push('Small but surfable waves');
    } else if (waveHeight > 3 && waveHeight <= 5) {
      score += 20;
      factors.push('Solid swell for experienced surfers');
    } else if (waveHeight > 5) {
      score += 10;
      factors.push('Large swell - experts only');
    } else {
      factors.push('Waves too small for surfing');
    }

    // Wave period score (0-25)
    if (wavePeriod >= 10 && wavePeriod <= 16) {
      score += 25;
      factors.push('Excellent wave period with clean swell');
    } else if (wavePeriod >= 8 && wavePeriod < 10) {
      score += 18;
      factors.push('Good wave period');
    } else if (wavePeriod >= 6 && wavePeriod < 8) {
      score += 12;
      factors.push('Short period wind swell');
    } else if (wavePeriod > 16) {
      score += 20;
      factors.push('Long period groundswell');
    } else {
      score += 5;
      factors.push('Very short period chop');
    }

    // Wind score (0-25)
    if (windSpeed == null) {
      score += 12;
      factors.push('Wind data unavailable');
    } else if (windSpeed < 5) {
      score += 25;
      factors.push('Light winds - glassy conditions likely');
    } else if (windSpeed < 10) {
      score += 18;
      factors.push('Moderate winds');
    } else if (windSpeed < 20) {
      score += 10;
      factors.push('Strong winds affecting conditions');
    } else {
      score += 3;
      factors.push('Very strong winds - choppy conditions');
    }

    // Offshore wind bonus (0-25)
    if (windDir != null && waveDir != null) {
      const diff = Math.abs(windDir - waveDir);
      const normalizedDiff = diff > 180 ? 360 - diff : diff;
      if (normalizedDiff > 135) {
        score += 25;
        factors.push('Offshore winds - clean wave faces');
      } else if (normalizedDiff > 90) {
        score += 15;
        factors.push('Cross-offshore winds');
      } else if (normalizedDiff > 45) {
        score += 8;
        factors.push('Cross-shore winds');
      } else {
        score += 3;
        factors.push('Onshore winds degrading conditions');
      }
    } else {
      score += 10;
    }

    const stars = Math.round(score / 20);
    let label;
    if (score >= 80) label = 'Epic';
    else if (score >= 65) label = 'Great';
    else if (score >= 50) label = 'Good';
    else if (score >= 35) label = 'Fair';
    else if (score >= 20) label = 'Poor';
    else label = 'Flat';

    return {
      score,
      stars: Math.min(stars, 5),
      label,
      explanation: factors.join('. ') + '.'
    };
  }

  // ============ API CALLS ============
  async function searchLocations(query) {
    if (!query || query.length < 2) return [];
    const url = `https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(query)}&count=5&language=en&format=json`;
    const res = await fetch(url);
    if (!res.ok) throw new Error('Geocoding failed');
    const data = await res.json();
    return data.results || [];
  }

  async function fetchForecast(lat, lon) {
    const marineUrl = `https://marine-api.open-meteo.com/v1/marine?latitude=${lat}&longitude=${lon}&hourly=wave_height,wave_direction,wave_period,swell_wave_height,swell_wave_direction,swell_wave_period&daily=wave_height_max,wave_direction_dominant,wave_period_max&timezone=auto&forecast_days=7`;
    const weatherUrl = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&hourly=temperature_2m,precipitation,wind_speed_10m,wind_direction_10m&daily=temperature_2m_max,temperature_2m_min,precipitation_sum&timezone=auto&forecast_days=7`;

    const [marineRes, weatherRes] = await Promise.all([
      fetch(marineUrl),
      fetch(weatherUrl)
    ]);

    if (!marineRes.ok || !weatherRes.ok) {
      throw new Error('Failed to fetch forecast data');
    }

    const marine = await marineRes.json();
    const weather = await weatherRes.json();

    return { marine, weather };
  }

  // ============ CACHE ============
  function getCacheKey(lat, lon) {
    return `waveclaude_cache_${lat.toFixed(2)}_${lon.toFixed(2)}`;
  }

  function cacheForcast(lat, lon, data) {
    try {
      const key = getCacheKey(lat, lon);
      localStorage.setItem(key, JSON.stringify({
        timestamp: Date.now(),
        data
      }));
    } catch (e) { console.error('Cache write failed', e); }
  }

  function getCachedForecast(lat, lon) {
    try {
      const key = getCacheKey(lat, lon);
      const cached = localStorage.getItem(key);
      if (!cached) return null;
      const { timestamp, data } = JSON.parse(cached);
      // Cache valid for 6 hours
      if (Date.now() - timestamp > 6 * 60 * 60 * 1000) {
        localStorage.removeItem(key);
        return null;
      }
      return data;
    } catch (e) { return null; }
  }

  // ============ RENDER ============
  function showState(stateName) {
    dom.emptyState.style.display = 'none';
    dom.forecastContent.style.display = 'none';
    dom.loadingState.style.display = 'none';
    dom.errorState.style.display = 'none';

    if (stateName === 'empty') dom.emptyState.style.display = 'block';
    else if (stateName === 'forecast') dom.forecastContent.style.display = 'block';
    else if (stateName === 'loading') dom.loadingState.style.display = 'block';
    else if (stateName === 'error') dom.errorState.style.display = 'block';
  }

  function renderAutocomplete(results) {
    dom.autocomplete.innerHTML = '';
    if (!results.length) {
      dom.autocomplete.classList.remove('show');
      return;
    }
    results.forEach(r => {
      const div = document.createElement('div');
      div.className = 'autocomplete-item';
      div.setAttribute('role', 'option');
      div.innerHTML = `<div class="name"></div><div class="country"></div>`;
      div.querySelector('.name').textContent = r.name;
      div.querySelector('.country').textContent = [r.admin1, r.country].filter(Boolean).join(', ');
      div.addEventListener('click', () => {
        playClickSound();
        selectLocation({ name: r.name, country: r.country, lat: r.latitude, lon: r.longitude });
        dom.autocomplete.classList.remove('show');
        dom.search.value = '';
      });
      dom.autocomplete.appendChild(div);
    });
    dom.autocomplete.classList.add('show');
  }

  function renderQuickRegions() {
    dom.quickRegions.innerHTML = '';
    quickRegions.forEach(r => {
      const btn = document.createElement('button');
      btn.className = 'region-btn';
      btn.textContent = r.name;
      btn.addEventListener('click', () => {
        playClickSound();
        selectLocation(r);
      });
      dom.quickRegions.appendChild(btn);
    });
  }

  function renderFavorites() {
    dom.favoritesRow.innerHTML = '';
    settings.favorites.forEach((f, i) => {
      const btn = document.createElement('button');
      btn.className = 'fav-btn';
      btn.innerHTML = `<span class="name"></span><span class="remove">√ó</span>`;
      btn.querySelector('.name').textContent = f.name;
      btn.addEventListener('click', e => {
        playClickSound();
        if (e.target.classList.contains('remove')) {
          settings.favorites.splice(i, 1);
          saveSettings();
          renderFavorites();
        } else {
          selectLocation(f);
        }
      });
      dom.favoritesRow.appendChild(btn);
    });
  }

  function updateFavStar() {
    if (!state.location) return;
    const isFav = settings.favorites.some(f =>
      f.lat === state.location.lat && f.lon === state.location.lon
    );
    dom.favStar.textContent = isFav ? '‚òÖ' : '‚òÜ';
    dom.favStar.classList.toggle('active', isFav);
  }

  function renderForecast() {
    if (!state.forecast || !state.location) return;

    const { marine, weather } = state.forecast;

    // Location info
    dom.locationName.textContent = state.location.name;
    dom.locationCoords.textContent = `${state.location.lat.toFixed(2)}¬∞, ${state.location.lon.toFixed(2)}¬∞`;
    dom.cacheBadge.classList.toggle('show', state.isCached);
    updateFavStar();

    // Find current hour index
    const now = new Date();
    const currentHourStr = now.toISOString().slice(0, 13);
    let hourIndex = 0;
    if (marine.hourly && marine.hourly.time) {
      hourIndex = marine.hourly.time.findIndex(t => t.startsWith(currentHourStr));
      if (hourIndex < 0) hourIndex = 0;
    }

    // Current conditions
    const waveH = marine.hourly?.wave_height?.[hourIndex];
    const waveP = marine.hourly?.wave_period?.[hourIndex];
    const waveD = marine.hourly?.wave_direction?.[hourIndex];
    const swellH = marine.hourly?.swell_wave_height?.[hourIndex];
    const windS = weather.hourly?.wind_speed_10m?.[hourIndex];
    const windD = weather.hourly?.wind_direction_10m?.[hourIndex];
    const temp = weather.hourly?.temperature_2m?.[hourIndex];
    const precip = weather.hourly?.precipitation?.[hourIndex];

    dom.currentWave.innerHTML = `${convertWave(waveH)}<span>${getWaveUnit()}</span>`;
    dom.currentPeriod.textContent = waveP != null ? `${waveP.toFixed(0)}s` : '--';
    dom.currentDirection.innerHTML = `${directionToText(waveD)} <span class="direction-arrow" style="transform: rotate(${(waveD || 0) + 180}deg)"">‚Üë</span>`;
    dom.currentSwell.textContent = swellH != null ? `${convertWave(swellH)}${getWaveUnit()}` : '--';
    dom.currentWind.textContent = `${convertWind(windS)} ${getWindUnit()}`;
    dom.currentWindDir.innerHTML = `${directionToText(windD)} <span class="direction-arrow" style="transform: rotate(${(windD || 0)}deg)">‚Üë</span>`;
    dom.currentTemp.textContent = `${convertTemp(temp)}¬∞${getTempUnit()}`;
    dom.currentPrecip.textContent = precip != null ? `${precip.toFixed(1)}mm` : '--';

    // Surf quality
    const quality = calculateSurfQuality(waveH, waveP, windS, windD, waveD);
    dom.qualityScore.textContent = quality.score;
    dom.qualityStars.textContent = '‚òÖ'.repeat(quality.stars) + '‚òÜ'.repeat(5 - quality.stars);
    dom.qualityLabel.textContent = quality.label;
    dom.qualityExplanation.textContent = quality.explanation;

    // Style quality score
    if (quality.score >= 65) dom.qualityScore.style.color = 'var(--good)';
    else if (quality.score >= 35) dom.qualityScore.style.color = 'var(--warn)';
    else dom.qualityScore.style.color = 'var(--bad)';

    // 48-hour timeline
    dom.timeline.innerHTML = '';
    const timeCount = Math.min(48, marine.hourly?.time?.length || 0);
    for (let i = hourIndex; i < hourIndex + timeCount && i < (marine.hourly?.time?.length || 0); i++) {
      const timeStr = marine.hourly.time[i];
      const wh = marine.hourly?.wave_height?.[i];
      const ws = weather.hourly?.wind_speed_10m?.[i];
      const tp = weather.hourly?.temperature_2m?.[i];

      const div = document.createElement('div');
      div.className = 'timeline-item' + (i === hourIndex ? ' now' : '');
      div.innerHTML = `
        <div class="timeline-time"></div>
        <div class="timeline-wave"></div>
        <div class="timeline-wind"></div>
        <div class="timeline-temp"></div>
      `;
      div.querySelector('.timeline-time').textContent = formatTime(timeStr, settings.time === '24');
      div.querySelector('.timeline-wave').textContent = `${convertWave(wh)}${getWaveUnit()}`;
      div.querySelector('.timeline-wind').textContent = `${convertWind(ws)}${getWindUnit()}`;
      div.querySelector('.timeline-temp').textContent = `${convertTemp(tp)}¬∞`;
      dom.timeline.appendChild(div);
    }

    // 7-day forecast
    dom.dailyForecast.innerHTML = '';
    const days = marine.daily?.time?.length || 0;
    for (let i = 0; i < days; i++) {
      const dayStr = marine.daily.time[i];
      const maxWave = marine.daily?.wave_height_max?.[i];
      const maxPeriod = marine.daily?.wave_period_max?.[i];
      const maxTemp = weather.daily?.temperature_2m_max?.[i];
      const minTemp = weather.daily?.temperature_2m_min?.[i];

      const div = document.createElement('div');
      div.className = 'daily-item';
      div.innerHTML = `
        <div class="daily-day"></div>
        <div class="daily-wave"></div>
        <div class="daily-period"></div>
        <div class="daily-temp"></div>
      `;
      div.querySelector('.daily-day').textContent = i === 0 ? 'Today' : formatDay(dayStr);
      div.querySelector('.daily-wave').textContent = `${convertWave(maxWave)}${getWaveUnit()}`;
      div.querySelector('.daily-period').textContent = maxPeriod != null ? `${maxPeriod.toFixed(0)}s period` : '';
      div.querySelector('.daily-temp').textContent = `${convertTemp(minTemp)}¬∞ / ${convertTemp(maxTemp)}¬∞`;
      dom.dailyForecast.appendChild(div);
    }
  }

  // ============ LOCATION SELECTION ============
  async function selectLocation(loc) {
    state.location = loc;
    state.isCached = false;
    showState('loading');

    try {
      if (state.isOnline) {
        const forecast = await fetchForecast(loc.lat, loc.lon);
        state.forecast = forecast;
        cacheForcast(loc.lat, loc.lon, forecast);
      } else {
        const cached = getCachedForecast(loc.lat, loc.lon);
        if (cached) {
          state.forecast = cached;
          state.isCached = true;
        } else {
          throw new Error('No cached data available offline');
        }
      }
      showState('forecast');
      renderForecast();
    } catch (err) {
      console.error(err);
      // Try cache as fallback
      const cached = getCachedForecast(loc.lat, loc.lon);
      if (cached) {
        state.forecast = cached;
        state.isCached = true;
        showState('forecast');
        renderForecast();
      } else {
        dom.errorMessage.textContent = err.message || 'Failed to load forecast';
        showState('error');
      }
    }
  }

  // ============ AUDIO ============
  function initAudio() {
    if (state.audioContext) return;
    state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
    state.masterGain = state.audioContext.createGain();
    state.masterGain.gain.value = settings.volume / 100 * 0.3;
    state.masterGain.connect(state.audioContext.destination);
  }

  function startAmbient() {
    if (!state.audioContext || state.ambientOsc) return;

    // Create multiple oscillators for ambient pad
    const osc1 = state.audioContext.createOscillator();
    const osc2 = state.audioContext.createOscillator();
    const osc3 = state.audioContext.createOscillator();

    osc1.type = 'sine';
    osc2.type = 'sine';
    osc3.type = 'triangle';

    osc1.frequency.value = 110;
    osc2.frequency.value = 165;
    osc3.frequency.value = 55;

    const filter = state.audioContext.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.value = 400;
    filter.Q.value = 1;

    const ambientGain = state.audioContext.createGain();
    ambientGain.gain.value = 0.15;

    osc1.connect(filter);
    osc2.connect(filter);
    osc3.connect(filter);
    filter.connect(ambientGain);
    ambientGain.connect(state.masterGain);

    osc1.start();
    osc2.start();
    osc3.start();

    // Slowly modulate frequencies for evolving sound
    function modulateFreq() {
      if (!state.audioEnabled) return;
      const now = state.audioContext.currentTime;
      const base1 = 110 + Math.sin(now * 0.1) * 5;
      const base2 = 165 + Math.sin(now * 0.07) * 8;
      osc1.frequency.setValueAtTime(base1, now);
      osc2.frequency.setValueAtTime(base2, now);
      requestAnimationFrame(modulateFreq);
    }
    modulateFreq();

    state.ambientOsc = { osc1, osc2, osc3, gain: ambientGain };
  }

  function stopAmbient() {
    if (!state.ambientOsc) return;
    try {
      state.ambientOsc.osc1.stop();
      state.ambientOsc.osc2.stop();
      state.ambientOsc.osc3.stop();
    } catch (e) {}
    state.ambientOsc = null;
  }

  function toggleAudio(enable) {
    state.audioEnabled = enable;
    if (enable) {
      initAudio();
      if (state.audioContext.state === 'suspended') {
        state.audioContext.resume();
      }
      startAmbient();
      dom.audioToggle.classList.add('active');
      dom.audioEnable.textContent = 'On';
      dom.audioEnable.classList.add('active');
    } else {
      stopAmbient();
      dom.audioToggle.classList.remove('active');
      dom.audioEnable.textContent = 'Off';
      dom.audioEnable.classList.remove('active');
    }
  }

  function setVolume(val) {
    settings.volume = val;
    saveSettings();
    if (state.masterGain) {
      state.masterGain.gain.value = val / 100 * 0.3;
    }
  }

  function playClickSound() {
    if (!state.audioEnabled || !state.audioContext) return;
    const osc = state.audioContext.createOscillator();
    const gain = state.audioContext.createGain();
    osc.type = 'sine';
    osc.frequency.value = 800;
    gain.gain.value = 0.1;
    osc.connect(gain);
    gain.connect(state.masterGain);
    osc.start();
    gain.gain.exponentialRampToValueAtTime(0.001, state.audioContext.currentTime + 0.1);
    osc.stop(state.audioContext.currentTime + 0.1);
  }

  // ============ SETTINGS UI ============
  function updateSettingsUI() {
    document.querySelectorAll('.setting-btn[data-setting]').forEach(btn => {
      const setting = btn.dataset.setting;
      const value = btn.dataset.value;
      btn.classList.toggle('active', settings[setting] === value);
    });
    dom.volumeSlider.value = settings.volume;
    if (state.audioEnabled) {
      dom.audioEnable.textContent = 'On';
      dom.audioEnable.classList.add('active');
    }
  }

  function openSettings() {
    playClickSound();
    updateSettingsUI();
    dom.settingsModal.classList.add('show');
  }

  function closeSettings() {
    playClickSound();
    dom.settingsModal.classList.remove('show');
    if (state.forecast) renderForecast();
  }

  // ============ EVENT HANDLERS ============
  const debouncedSearch = debounce(async (query) => {
    if (!query || query.length < 2) {
      dom.autocomplete.classList.remove('show');
      return;
    }
    try {
      const results = await searchLocations(query);
      renderAutocomplete(results);
    } catch (e) {
      console.error('Search error', e);
    }
  }, 300);

  dom.search.addEventListener('input', e => {
    debouncedSearch(e.target.value.trim());
  });

  dom.search.addEventListener('focus', () => {
    if (dom.autocomplete.children.length > 0) {
      dom.autocomplete.classList.add('show');
    }
  });

  document.addEventListener('click', e => {
    if (!dom.search.contains(e.target) && !dom.autocomplete.contains(e.target)) {
      dom.autocomplete.classList.remove('show');
    }
  });

  dom.favStar.addEventListener('click', () => {
    playClickSound();
    if (!state.location) return;
    const idx = settings.favorites.findIndex(f =>
      f.lat === state.location.lat && f.lon === state.location.lon
    );
    if (idx >= 0) {
      settings.favorites.splice(idx, 1);
    } else {
      settings.favorites.push({ ...state.location });
    }
    saveSettings();
    renderFavorites();
    updateFavStar();
  });

  dom.retryBtn.addEventListener('click', () => {
    playClickSound();
    if (state.location) selectLocation(state.location);
  });

  dom.audioToggle.addEventListener('click', () => {
    toggleAudio(!state.audioEnabled);
  });

  dom.settingsBtn.addEventListener('click', openSettings);
  dom.settingsClose.addEventListener('click', closeSettings);

  dom.settingsModal.addEventListener('click', e => {
    if (e.target === dom.settingsModal) closeSettings();
  });

  document.querySelectorAll('.setting-btn[data-setting]').forEach(btn => {
    btn.addEventListener('click', () => {
      playClickSound();
      const setting = btn.dataset.setting;
      const value = btn.dataset.value;
      settings[setting] = value;
      saveSettings();
      updateSettingsUI();
    });
  });

  dom.audioEnable.addEventListener('click', () => {
    toggleAudio(!state.audioEnabled);
  });

  dom.volumeSlider.addEventListener('input', e => {
    setVolume(parseInt(e.target.value, 10));
  });

  // Online/Offline detection
  window.addEventListener('online', () => {
    state.isOnline = true;
    if (state.location && state.isCached) {
      selectLocation(state.location);
    }
  });

  window.addEventListener('offline', () => {
    state.isOnline = false;
  });

  // Keyboard nav for autocomplete
  dom.search.addEventListener('keydown', e => {
    const items = dom.autocomplete.querySelectorAll('.autocomplete-item');
    if (!items.length) return;

    const focused = dom.autocomplete.querySelector('.autocomplete-item:focus');
    let index = Array.from(items).indexOf(focused);

    if (e.key === 'ArrowDown') {
      e.preventDefault();
      index = Math.min(index + 1, items.length - 1);
      items[index]?.focus();
    } else if (e.key === 'ArrowUp') {
      e.preventDefault();
      index = Math.max(index - 1, 0);
      items[index]?.focus();
    } else if (e.key === 'Enter' && focused) {
      e.preventDefault();
      focused.click();
    } else if (e.key === 'Escape') {
      dom.autocomplete.classList.remove('show');
    }
  });

  // ============ INIT ============
  function init() {
    loadSettings();
    renderQuickRegions();
    renderFavorites();
    showState('empty');
  }

  init();
})();
</script>
</body>
</html>
